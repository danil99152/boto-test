## Boto URL Shortener

Небольшое тестовое приложение-сократитель ссылок для задания «Middle Backend Developer (Python)».

Реализованы два эндпоинта:
- `POST /shorten` — принимает длинный URL и возвращает короткий;
- `GET /{code}` — выполняет HTTP‑редирект по короткому коду.

В качестве хранилища используется `sqlite3` из стандартной библиотеки, без ORM. API реализован на FastAPI.

---

### Требования

- Python 3.12+
- git

Рекомендуется использовать виртуальное окружение (`venv` или аналог).

---

### Установка зависимостей

```bash
python -m venv .venv
source .venv/bin/activate  # Windows: .venv\Scripts\activate
pip install -e .[dev]
```

---

### Запуск приложения

Из корня проекта:

```bash
python -m app.main
```

По умолчанию приложение поднимается на `http://127.0.0.1:8000`.

Доступна стандартная интерактивная документация FastAPI:
- Swagger UI: `http://127.0.0.1:8000/docs`
- ReDoc: `http://127.0.0.1:8000/redoc`

---

### Переменные окружения

- **`SHORTENER_DB_PATH`** — путь к файлу sqlite-базы. По умолчанию: `shortener.db` в корне проекта.
- **`BASE_URL`** — базовый URL сервиса, который используется при формировании ответа `short_url` в `POST /shorten`.
  - Например: `http://localhost:8000` или `https://short.my-domain.com`.
  - Если переменная не задана, в ответе возвращается относительный путь `/{code}`.
- **`LOG_LEVEL`** — уровень логирования (например, `INFO`, `DEBUG`). По умолчанию: `INFO`.
- **`PORT`** — порт uvicorn (по умолчанию `8000`).
- **`RELOAD`** — режим авто-перезапуска кода при разработке (`true`/`false`, по умолчанию `true`).

Запуск с использованием переменных окружения, пример:

```bash
export SHORTENER_DB_PATH=./data/shortener.db
export BASE_URL=http://localhost:8000
python -m app.main
```

---

### Эндпоинты

#### `POST /shorten`

**Запрос (JSON):**

```json
{
  "url": "https://example.com/some/long/path"
}
```

`url` — валидный HTTP(S) URL. Валидация выполняется через `pydantic.HttpUrl`.

**Ответ (JSON):**

```json
{
  "short_url": "http://localhost:8000/AbCd1234"
}
```

Формат `short_url`:
- Если задан `BASE_URL`, используется он;
- иначе возвращается относительный путь `/{code}`.

Код генерируется псевдослучайно (буквы латинского алфавита + цифры, длина 8 символов). Коллизии обрабатываются попыткой повторной генерации; в логи пишется предупреждение.

#### `GET /{code}`

Выполняет редирект на исходный URL (код 307).

- **Успех**: `307 Temporary Redirect` с заголовком `Location: <original_url>`.
- **Ошибка**: если код не найден — `404 Not Found` с сообщением `"Short URL not found"`.

---

### Тестирование

Зависимости для тестов устанавливаются через `pip install -e .[dev]`.

Запуск всех тестов:

```bash
pytest
```

Тесты используют отдельный временный sqlite-файл (переменная `SHORTENER_DB_PATH` переназначается на время тестов), чтобы не мешать рабочей БД.

Покрыты сценарии:
- создание короткой ссылки и успешный редирект;
- корректное поведение при обращении к несуществующему коду (404).

---

### Структура проекта

- `pyproject.toml` — метаданные проекта и зависимости, включая extras `[dev]` для тестов.
- `app/db.py` — инициализация и доступ к sqlite-базе (создание таблицы `urls`, контекстный менеджер соединения).
- `app/repository.py` — бизнес-логика работы с БД: генерация кода, создание записи, поиск оригинального URL.
- `app/schemas.py` — pydantic-схемы запросов/ответов (`ShortenRequest`, `ShortenResponse`).
- `app/main.py` — определение FastAPI-приложения, маршрутов, логирования и точки входа.
- `tests/test_shortener.py` — pytest-тесты эндпоинтов.

---

### Логирование

Логирование настроено через `logging.basicConfig`:
- формат: время, уровень, логгер, сообщение;
- уровень задаётся через переменную `LOG_LEVEL`.

Логируются:
- инициализация БД;
- ошибки работы с БД (rollback транзакции);
- успешное создание коротких ссылок и коллизии кодов;
- операции редиректа и попытки доступа к несуществующему коду.

---

### Письмо с комментариями (как для ревьюера)

**Плюсы реализации**

- **Простая и прозрачная архитектура**: отделены уровни БД (`db.py`), бизнес-логика (`repository.py`) и HTTP-слой (`main.py`, `schemas.py`). Это упрощает доработку и тестирование.
- **Использование стандартных инструментов**: `sqlite3` из стандартной библиотеки, FastAPI для API, `pytest` для тестов, `pyproject.toml` как единая точка конфигурации.
- **Валидный и безопасный ввод**: URL валидируется через `pydantic.HttpUrl`, что отсекает очевидно некорректные значения на входе.
- **Логирование ключевых событий**: создание ссылок, коллизии кодов, редиректы и ошибки попадают в логи.
- **Тесты для основных сценариев**: happy-path (создание + редирект) и обращение к несуществующему коду.

**Минусы и ограничения**

- **Нет авторизации и управления пользователями**: сервис полностью открытый, любые запросы могут создавать ссылки.
- **Простая схема БД**: нет счётчиков переходов, TTL ссылок, дополнительных атрибутов (описания, тегов и т.п.).
- **Нет сложной валидации/нормализации URL**: принимается и хранится строка, которую даёт `HttpUrl`; не реализовано, например, авто-добавление схемы для "сырой" строки.
- **Нет rate limiting и защиты от злоупотреблений**: при реальной эксплуатации потребовались бы ограничения по IP/токену и защита от спама.
- **Примитивный генератор кода**: вероятность коллизий низкая, но при очень большом количестве записей потребовалось бы более продуманное решение (например, инкрементальный ID + кодирование).

**Что не успел(а)/сделано минимально**

- Нет вспомогательных эндпоинтов для просмотра/удаления/редактирования ссылок.
- Нет отдельного конфигурационного слоя (например, через pydantic settings); конфигурация читается напрямую из `os.environ`.
- Нет настроек типа CORS, хедеров безопасности и т.п. — для тестового задания это избыточно, но в бою понадобилось бы.

**Как бы развивал(а) этот проект дальше**

- Добавил(а) бы **эндпоинты управления ссылками**:
  - удаление/деактивация ссылки;
  - редактирование оригинального URL;
  - создание ссылки с заданным коротким кодом (с проверкой коллизий и прав).
- Ввёл(ла) бы **учёт пользователей** (простая аутентификация + привязка ссылок к владельцу).
- Реализовал(а) бы **метрики и аналитику**:
  - счётчик переходов по каждой ссылке;
  - время последнего перехода;
  - отдельную таблицу с логом кликов (IP, user-agent, referrer) с возможностью агрегации.
- Вынес(ла) бы конфигурацию в отдельный модуль (pydantic settings) и добавил(а) разные профили (dev/test/prod).
- Для высокой нагрузки перенёс(ла) бы хранилище с sqlite на внешний Postgres/Redis и оснастил(а) сервис метриками (Prometheus) и алертингом.

# boto-test